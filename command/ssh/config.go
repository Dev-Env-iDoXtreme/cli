package ssh

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/pkg/errors"
	"github.com/smallstep/cli/command"
	"github.com/smallstep/cli/config"
	"github.com/smallstep/cli/errs"
	"github.com/smallstep/cli/flags"
	"github.com/smallstep/cli/utils"
	"github.com/smallstep/cli/utils/cautils"
	"github.com/urfave/cli"
	"golang.org/x/crypto/ssh"
)

const (
	configHeader = "# autogenerated by step ssh config"
	configFooter = "# end"
)

func configCommand() cli.Command {
	return cli.Command{
		Name:      "config",
		Action:    command.ActionFunc(configAction),
		Usage:     "configures ssh and set known_hosts",
		UsageText: `**step ssh config**`,
		Description: `**step ssh config** configures SSH configuration and known hosts to use SSH
certificates provided by step-certificates.

## EXAMPLES

Print the line to add to the user's known_host file:
'''
$ step ssh config --dry-run
'''

Print the line to add to the host TrustedUserCAKeys file:
'''
$ step ssh config --host --dry-run
'''

Add the certificate authority used to sign host certificates to your
known_hosts:
'''
$ step ssh config
'''

Add the certificate authority used to sign client certificates to your
sshd_config:
'''
$ step ssh config --host
'''

Add the certificate authority used to sign client certificates and
configure a specific host certificate and key:
'''
$ step ssh config --host --cert host-key-cert.pub --key host-key
'''`,
		Flags: []cli.Flag{
			cli.BoolFlag{
				Name:  "host",
				Usage: "Configures a SSH server instead of a client.",
			},
			cli.StringFlag{
				Name:  "cert",
				Usage: "The <path> of the host certificate to add in the OpenSSH daemon configuration.",
			},
			cli.StringFlag{
				Name:  "key",
				Usage: "The <path> of the host key to add in the OpenSSH daemon configuration.",
			},
			cli.StringFlag{
				Name:  "sshd-config",
				Usage: "The <path> to the OpenSSH daemon configuration. Defaults to /etc/ssh/sshd_config.",
				Value: "/etc/ssh/sshd_config",
			},
			cli.StringFlag{
				Name:  "known-hosts",
				Usage: "The <path> to the OpenSSH client known hosts file. Defaults to ~/.ssh/known_hosts.",
			},
			flags.CaURL,
			flags.Root,
			flags.Offline,
			flags.CaConfig,
			flags.DryRun,
		},
	}
}

type statusCoder interface {
	StatusCode() int
}

func configAction(ctx *cli.Context) error {
	isHost := ctx.Bool("host")
	cert := ctx.String("cert")
	key := ctx.String("key")

	switch {
	case !isHost && cert != "":
		return errs.RequiredWithFlag(ctx, "cert", "host")
	case !isHost && key != "":
		return errs.RequiredWithFlag(ctx, "key", "host")
	}

	client, err := cautils.NewClient(ctx)
	if err != nil {
		return err
	}

	// Get certificate keys
	keys, err := client.SSHKeys()
	if err != nil {
		if e, ok := err.(statusCoder); ok && e.StatusCode() == http.StatusNotFound {
			return errors.New("step certificates is not configured with SSH support")
		}
		return errors.Wrap(err, "error getting ssh public keys")
	}

	// Host configuration
	if isHost {
		if keys.UserKey == nil {
			return errors.New("step certificates is not configured with an ssh.userKey")
		}
		if ctx.Bool("dry-run") {
			return configActionDryRun(ctx, keys.UserKey)
		}

		return editSSHDConfig(ctx, keys.UserKey.PublicKey)
	}

	// User configuration
	if keys.HostKey == nil {
		return errors.New("step certificates is not configured with an ssh.hostKey")
	}
	if ctx.Bool("dry-run") {
		return configActionDryRun(ctx, keys.HostKey)
	}

	return editKknownHosts(ctx, keys.HostKey)
}

func configActionDryRun(ctx *cli.Context, key ssh.PublicKey) error {
	if ctx.Bool("host") {
		fmt.Printf("%s %s\n", key.Type(), base64.StdEncoding.EncodeToString(key.Marshal()))
	} else {
		fmt.Printf("@cert-authority * %s %s\n", key.Type(), base64.StdEncoding.EncodeToString(key.Marshal()))
	}
	return nil
}

func editKknownHosts(ctx *cli.Context, key ssh.PublicKey) error {
	filename := ctx.String("known-hosts")
	if filename == "" {
		home, err := config.Home()
		if err != nil {
			return errs.RequiredFlag(ctx, "known-hosts")
		}
		filename = filepath.Join(home, ".ssh", "known_hosts")
	}
	mode := os.FileMode(0644)
	if st, err := os.Stat(filename); err == nil {
		mode = st.Mode()
	}
	cert := fmt.Sprintf("@cert-authority * %s %s\n", key.Type(), base64.StdEncoding.EncodeToString(key.Marshal()))
	return utils.AppendNewLine(filename, []byte(cert), mode)
}

func editSSHDConfig(ctx *cli.Context, key ssh.PublicKey) error {
	filename := ctx.String("sshd-config")
	if filename == "" {
		filename = "/etc/ssh/sshd_config"
	}

	st, err := os.Stat(filename)
	if err != nil {
		return errs.FileError(err, filename)
	}

	abs, err := filepath.Abs(filename)
	if err != nil {
		return errors.Wrapf(err, "error getting absolute path for %s", filename)
	}
	base := filepath.Dir(abs)

	// Parse sshd_config
	var caFilename, hostCertificate, hostKey string
	b, err := ioutil.ReadFile(filename)
	if err != nil {
		return errs.FileError(err, filename)
	}
	config, start, end := findConfiguration(bytes.NewReader(b))
	for _, cfg := range config {
		fields := strings.Fields(cfg)
		if len(fields) >= 2 {
			switch fields[0] {
			case "TrustedUserCAKeys":
				caFilename = fields[1]
			case "HostCertificate":
				hostCertificate = fields[1]
			case "HostKey":
				hostKey = fields[1]
			}
		}
	}
	if caFilename == "" {
		caFilename = filepath.Join(base, "ca.pub")
		config = append(config, fmt.Sprintf("TrustedUserCAKeys %s", caFilename))
	}
	if cert := ctx.String("cert"); cert != "" && cert != hostCertificate {
		path, err := filepath.Abs(cert)
		if err != nil {
			return errors.Wrapf(err, "error getting absolute path for %s", cert)
		}
		config = append(config, fmt.Sprintf("HostCertificate %s", path))
	}
	if key := ctx.String("key"); key != "" && key != hostKey {
		path, err := filepath.Abs(key)
		if err != nil {
			return errors.Wrapf(err, "error getting absolute path for %s", key)
		}
		config = append(config, fmt.Sprintf("HostKey %s", path))
	}

	// Write sshd_config
	f, err := utils.OpenFile(filename, os.O_WRONLY|os.O_TRUNC, st.Mode())
	if err != nil {
		return errs.FileError(err, filename)
	}
	f.Write(b[:start])
	if start == end {
		f.WriteString("\n")
	}
	f.WriteString(fmt.Sprintf("%s @ %s\n", configHeader, time.Now().UTC().Format(time.RFC3339)))
	for _, cfg := range config {
		f.WriteString(cfg + "\n")
	}
	f.WriteString(configFooter + "\n")
	f.Write(b[end:])
	if err := f.Close(); err != nil {
		return errs.FileError(err, filename)
	}

	// Add cert to ca.pub if necessary
	var mode = st.Mode()
	cert := fmt.Sprintf("%s %s\n", key.Type(), base64.StdEncoding.EncodeToString(key.Marshal()))
	if st, err = os.Stat(caFilename); err == nil {
		mode = st.Mode()
	} else {
		return utils.WriteFile(caFilename, []byte(cert), mode)
	}

	b, err = ioutil.ReadFile(caFilename)
	if err != nil {
		return errs.FileError(err, caFilename)
	}
	if !bytes.Contains(b, []byte(cert)) {
		return utils.AppendNewLine(caFilename, []byte(cert), mode)
	}

	return nil
}

type offsetCounter struct {
	offset int64
}

func (o *offsetCounter) ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error) {
	advance, token, err = bufio.ScanLines(data, atEOF)
	o.offset += int64(advance)
	return
}

func findConfiguration(r io.Reader) (lines []string, start int64, end int64) {
	var inConfig bool
	counter := new(offsetCounter)
	scanner := bufio.NewScanner(r)
	scanner.Split(counter.ScanLines)
	for scanner.Scan() {
		line := scanner.Text()
		switch {
		case !inConfig && strings.HasPrefix(line, configHeader):
			inConfig = true
			start = counter.offset - int64(len(line)+1)
		case inConfig && strings.HasPrefix(line, configFooter):
			return lines, start, counter.offset
		case inConfig:
			lines = append(lines, line)
		}
	}

	return lines, counter.offset, counter.offset
}
